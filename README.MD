# Memory Size

This is easy to use Composer package to deal with human-friendly formatted sizes of memory blocks or files
(like "32 KB", "4.87 MiB"). It consist of 2 parts: Parser and Formatter. Parser allows to parse formatted
sizes. Formatter allows to format size to human-friendly view. They are compatible each other, so parser
able to parse string generated by formatter and vise-versa. This package was made with focus on international 
standards. Generally there's two main standards:
1. JEDEC Standard 100B.01 (JESD100B.01) (https://en.wikipedia.org/wiki/JEDEC_memory_standards)
2. ISO/IEC 80000 (https://en.wikipedia.org/wiki/ISO/IEC_80000)  

The JESD100B.01 describes old-style measure units like "KB", "MB" & "GB" which are means 1024 bytes, 1024^2
bytes & 1024^3 bytes accordingly. Although these measure units are well-known and popular they are deprecated
because they collide with SI (metric) prefixes where "M" means 1000^2 (million) and "G" means 1000^3 (billion).
By the way, with "Kilo" prefix there's no collision because SI-prefix for "Kilo" defined as "k" (lowercase).
Also JESD100B.01 allows to use shortened records contains only prefix, i.e. "K", "M" and "G". These records
are little confusing but not so inconsistent as "KB", "MB" and "GB". Note that JESD100B.01 defines only
kilobytes, megabytes and gigabytes. It's not defined terabytes, petabytes and so on. So "TB" unit should not
be treated as 1024^4.

The ISO/IEC 80000 more modern standard. It solves problem of inconsistency memory prefixes and SI-prefixes
by introducing new binary prefixes especially for degrees of 2: "KiB", "MiB", "GiB", "TiB", "PiB", etc.
which means 1024^1, 1024^2, 1024^3, 1024^4, 1024^5, etc. But this standard also refers to SI-prefixes.
So, "1 MB" means 1000000 (1000^2) bytes, "1 GB" means 1000000000 (1000^3) bytes and so on.

These two standards (JESD100B.01 and ISO/IEC 80000) are implemented as separated classes with standard 
interface. You may define which standard to use or you can make your own standard implementation and pass
your standard instance to the parser or to the formatter. 
 
## Parser

For example, you want to accept from a user the size of anything in bytes (e.g. via config file or command
line arguments). Of course, you can force a user to specify the exact size in bytes. But this is not very
convenient when it comes to gigabytes and terabytes. Or maybe you need to parse data that already contains 
formatted file sizes like "700M" or "4.38GB". You may use this parser for this. Here's an example:

```
<?php

require_once __DIR__ . '/vendor/autoload.php';

$parser = new \gugglegum\MemorySize\Parser();
var_dump($parser->parse('700M'));

```

Will produce output:

```
int(734003200)
```

Parser uses standard implementations to parse formatted size. It can use several standards. At first it 
tries to parse measure unit by first standard. If it doesn't know this unit, it tries second and so on.
By default parser uses the ISO/IEC 80000 as first (primary) and the JESD100B.01 as second (secondary).
So it will parse both "32K" form and "32 KiB" correctly. But if you need to treat "8 MB" or "2 GB" as
binary prefixes, you need to remove ISO/IEC 80000 standard or to make JESD100B.01 first (primary).

This is an example how to make JESD100B.01 standard primary and ISO/IEC 80000 standard secondary:

```
<?php

require_once __DIR__ . '/vendor/autoload.php';

$parser = new \gugglegum\MemorySize\Parser([
    'standards' => [
        new \gugglegum\MemorySize\Standards\JEDEC(),
        new \gugglegum\MemorySize\Standards\IEC(),
    ],
]);

var_dump($parser->parse('32 kB'));
var_dump($parser->parse('32 KB'));
var_dump($parser->parse('32 KiB'));

var_dump($parser->parse('8 MB'));
var_dump($parser->parse('8 MiB'));

```

Will produce output:

```
int(32000)
int(32768)
int(32768)
int(8388608)
int(8388608)
```

You may see here that "32 kB" parses as 32000 because lowercase "k" prefix is only SI-prefix. Binary kilo prefix
is uppercase "K". This is why "32 KB" parses as 32768. "32 KiB" always parses by ISO/IEC 80000 as 32768 because "Ki"
is a special binary called "kibi". "8 MB" parses as 8388608 because JEDEC is primary and it treats this prefix
as binary. "8 MiB" always parses by ISO/IEC 80000 as 8388608 because "Mi" is a special binary prefix called "mebi".

## Formatter

As opposed to the parser you may need a formatter to memory sizes or file sizes in human-friendly view. The 
formatter uses standard objects too. But unlike the parser the formatter may use only one standard at once.
By default formatter uses ISO/IEC 80000 standard and uses only binary prefixes ("KiB", "MiB", "GiB", etc).
Here's example how to use formatter:

```
<?php

require_once __DIR__ . '/vendor/autoload.php';

$formatter = new \gugglegum\MemorySize\Formatter();
var_dump($formatter->format(32768));
var_dump($formatter->format(1536));
var_dump($formatter->format(1000000));
var_dump($formatter->format(1048576));
```

Will produce output:

```
string(6) "32 KiB"
string(7) "1.5 KiB"
string(10) "976.56 KiB"
string(5) "1 MiB"
```

If you need old-style format from JESD100B.01 you may set to use it instead of ISO/IEC 80000. Here's an
example how to do this:

```
<?php

require_once __DIR__ . '/vendor/autoload.php';

$formatter = new \gugglegum\MemorySize\Formatter([
    'standard' => new \gugglegum\MemorySize\Standards\JEDEC(),
]);
var_dump($formatter->format(32768));
var_dump($formatter->format(1536));
var_dump($formatter->format(1000000));
var_dump($formatter->format(1048576));
```

Will produce output:

```
string(5) "32 KB"
string(6) "1.5 KB"
string(9) "976.56 KB"
string(4) "1 MB"
```

## Requirements

This class written to be executed on PHP version 7.0 or better. It uses `define(strict_types=1)`
and scalar types in methods definition.
